"use strict";(globalThis.webpackChunkgratitude_token_project_docs=globalThis.webpackChunkgratitude_token_project_docs||[]).push([[3755],{6765:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var r=t(6771),s=t(4848),a=t(8453);const i={slug:"smart-contract-architecture-deep-dive",title:"Smart Contract Architecture Deep Dive",authors:["christopher"],tags:["solidity","smart-contracts","ethereum","architecture","technical"]},o="Smart Contract Architecture Deep Dive",l={authorsImageUrls:[void 0]},c=[{value:"\ud83c\udfd7\ufe0f Contract Overview",id:"\ufe0f-contract-overview",level:2},{value:"Token Contracts (7)",id:"token-contracts-7",level:3},{value:"Core Contracts (5)",id:"core-contracts-5",level:3},{value:"\ud83c\udfaf Design Principles",id:"-design-principles",level:2},{value:"1. Separation of Concerns",id:"1-separation-of-concerns",level:3},{value:"2. Composability",id:"2-composability",level:3},{value:"3. Immutability Where Possible",id:"3-immutability-where-possible",level:3},{value:"4. Upgradeability Where Needed",id:"4-upgradeability-where-needed",level:3},{value:"\ud83d\udd25 Sacred Altar Contract",id:"-sacred-altar-contract",level:2},{value:"Full Implementation",id:"full-implementation",level:3},{value:"Key Features Explained",id:"key-features-explained",level:3},{value:"1. ReentrancyGuard",id:"1-reentrancyguard",level:4},{value:"2. Pausable",id:"2-pausable",level:4},{value:"3. Immutable References",id:"3-immutable-references",level:4},{value:"4. Event Logging",id:"4-event-logging",level:4},{value:"\ud83d\udd12 Security Patterns",id:"-security-patterns",level:2},{value:"1. Checks-Effects-Interactions",id:"1-checks-effects-interactions",level:3},{value:"2. Pull Over Push",id:"2-pull-over-push",level:3},{value:"3. Integer Overflow Protection",id:"3-integer-overflow-protection",level:3},{value:"4. Access Control",id:"4-access-control",level:3},{value:"\ud83e\uddea Testing Strategy",id:"-testing-strategy",level:2},{value:"Unit Tests",id:"unit-tests",level:3},{value:"Integration Tests",id:"integration-tests",level:3},{value:"Fuzzing",id:"fuzzing",level:3},{value:"\ud83d\udcca Gas Optimization",id:"-gas-optimization",level:2},{value:"1. Use <code>immutable</code> and <code>constant</code>",id:"1-use-immutable-and-constant",level:3},{value:"2. Pack Storage Variables",id:"2-pack-storage-variables",level:3},{value:"3. Use Events Instead of Storage",id:"3-use-events-instead-of-storage",level:3},{value:"\ud83d\ude80 Deployment Strategy",id:"-deployment-strategy",level:2},{value:"1. Deploy in Correct Order",id:"1-deploy-in-correct-order",level:3},{value:"2. Verify on Etherscan",id:"2-verify-on-etherscan",level:3},{value:"3. Renounce Ownership (if appropriate)",id:"3-renounce-ownership-if-appropriate",level:3},{value:"\ud83d\udcda Resources",id:"-resources",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Welcome to a comprehensive exploration of the ",(0,s.jsx)(n.strong,{children:"Ethereal Offering smart contract architecture"}),". In this post, we'll dive deep into how our contracts are structured, the design patterns we use, and the security considerations that guide our development."]}),"\n",(0,s.jsx)(n.h2,{id:"\ufe0f-contract-overview",children:"\ud83c\udfd7\ufe0f Contract Overview"}),"\n",(0,s.jsxs)(n.p,{children:["The Ethereal Offering ecosystem consists of ",(0,s.jsx)(n.strong,{children:"12 core smart contracts"})," that work together to create a complete DeFi and ceremonial platform:"]}),"\n",(0,s.jsx)(n.h3,{id:"token-contracts-7",children:"Token Contracts (7)"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"PsiloToken.sol"})," - ERC-20 crowdsale token"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MDAOToken.sol"})," - ERC-20 governance token"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"EthoToken.sol"})," - ERC-20 ceremonial burn token"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"PSDToken.sol"})," - ERC-20 stablecoin"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DMToken.sol"})," - ERC-20 daily rewards token"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ProofOfBurn.sol"})," - ERC-721 soulbound NFT"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MushroomNFT.sol"})," - ERC-721 breeding NFT"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"core-contracts-5",children:"Core Contracts (5)"}),"\n",(0,s.jsxs)(n.ol,{start:"8",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SacredAltar.sol"})," - Ceremonial burning mechanism"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Crowdsale.sol"})," - PSILO token sale"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Staking.sol"})," - PSILO \u2192 MDAO staking"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"AMM.sol"})," - Automated market maker"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DAOTreasury.sol"})," - Multi-sig treasury"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-design-principles",children:"\ud83c\udfaf Design Principles"}),"\n",(0,s.jsx)(n.h3,{id:"1-separation-of-concerns",children:"1. Separation of Concerns"}),"\n",(0,s.jsxs)(n.p,{children:["Each contract has a ",(0,s.jsx)(n.strong,{children:"single, well-defined responsibility"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// \u274c BAD: One contract doing everything\ncontract MonolithicContract {\n    function buyTokens() external {}\n    function stakeTokens() external {}\n    function burnTokens() external {}\n    function swapTokens() external {}\n    // ... 50 more functions\n}\n\n// \u2705 GOOD: Separate contracts for separate concerns\ncontract Crowdsale {\n    function buyTokens() external {}\n}\n\ncontract Staking {\n    function stakeTokens() external {}\n}\n\ncontract SacredAltar {\n    function burnTokens() external {}\n}\n\ncontract AMM {\n    function swapTokens() external {}\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Easier to audit and test"}),"\n",(0,s.jsx)(n.li,{children:"Simpler to upgrade individual components"}),"\n",(0,s.jsx)(n.li,{children:"Reduced attack surface"}),"\n",(0,s.jsx)(n.li,{children:"Better gas optimization"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-composability",children:"2. Composability"}),"\n",(0,s.jsxs)(n.p,{children:["Contracts are designed to ",(0,s.jsx)(n.strong,{children:"work together"})," through well-defined interfaces:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// Interface for token burning\ninterface IBurnable {\n    function burn(uint256 amount) external;\n}\n\n// Interface for NFT minting\ninterface IMintable {\n    function mint(address to, uint256 tokenId) external;\n}\n\n// Sacred Altar composes these interfaces\ncontract SacredAltar {\n    IBurnable public ethoToken;\n    IMintable public pobNFT;\n    \n    function makeOffering(uint256 amount) external {\n        // Burn ETHO tokens\n        ethoToken.burn(amount);\n        \n        // Mint POB NFT\n        pobNFT.mint(msg.sender, nextTokenId++);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-immutability-where-possible",children:"3. Immutability Where Possible"}),"\n",(0,s.jsxs)(n.p,{children:["Critical parameters are ",(0,s.jsx)(n.strong,{children:"immutable"})," to prevent tampering:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"contract PsiloToken {\n    // \u2705 Immutable - can never change\n    uint256 public immutable TOTAL_SUPPLY = 10_000_000 * 10**18;\n    address public immutable TREASURY;\n    \n    // \u274c Mutable - could be changed by owner\n    // uint256 public totalSupply;\n    // address public treasury;\n    \n    constructor(address _treasury) {\n        TREASURY = _treasury;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-upgradeability-where-needed",children:"4. Upgradeability Where Needed"}),"\n",(0,s.jsxs)(n.p,{children:["Some contracts use ",(0,s.jsx)(n.strong,{children:"proxy patterns"})," for upgrades:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'// Transparent Proxy Pattern\ncontract SacredAltarProxy {\n    address public implementation;\n    address public admin;\n    \n    function upgradeTo(address newImplementation) external {\n        require(msg.sender == admin, "Not admin");\n        implementation = newImplementation;\n    }\n    \n    fallback() external payable {\n        address impl = implementation;\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to use proxies:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 Complex logic that may need bug fixes"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Features that will evolve over time"}),"\n",(0,s.jsx)(n.li,{children:"\u274c Token contracts (immutability is trust)"}),"\n",(0,s.jsx)(n.li,{children:"\u274c Treasury (security over flexibility)"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-sacred-altar-contract",children:"\ud83d\udd25 Sacred Altar Contract"}),"\n",(0,s.jsxs)(n.p,{children:["Let's dive deep into the ",(0,s.jsx)(n.strong,{children:"most important contract"})," in the ecosystem:"]}),"\n",(0,s.jsx)(n.h3,{id:"full-implementation",children:"Full Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport "@openzeppelin/contracts/security/ReentrancyGuard.sol";\nimport "@openzeppelin/contracts/security/Pausable.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\n\ninterface IEthoToken {\n    function burnFrom(address account, uint256 amount) external;\n}\n\ninterface IProofOfBurn {\n    function mint(address to, uint256 burnAmount, bytes32 intention) external returns (uint256);\n}\n\ninterface IDAOTreasury {\n    function deposit() external payable;\n}\n\n/**\n * @title SacredAltar\n * @notice Ceremonial token burning contract\n * @dev Burns ETHO tokens and mints POB NFTs as receipts\n */\ncontract SacredAltar is ReentrancyGuard, Pausable, Ownable {\n    \n    // ============ State Variables ============\n    \n    IEthoToken public immutable ethoToken;\n    IProofOfBurn public immutable pobNFT;\n    IDAOTreasury public immutable treasury;\n    \n    uint256 public totalBurned;\n    uint256 public totalOfferings;\n    \n    mapping(address => uint256) public userTotalBurned;\n    mapping(address => uint256) public userOfferingCount;\n    \n    // ============ Events ============\n    \n    event OfferingMade(\n        address indexed user,\n        uint256 amount,\n        uint256 pobTokenId,\n        bytes32 intention,\n        uint256 timestamp\n    );\n    \n    event TreasuryDeposit(uint256 amount);\n    \n    // ============ Constructor ============\n    \n    constructor(\n        address _ethoToken,\n        address _pobNFT,\n        address _treasury\n    ) {\n        require(_ethoToken != address(0), "Invalid ETHO address");\n        require(_pobNFT != address(0), "Invalid POB address");\n        require(_treasury != address(0), "Invalid treasury address");\n        \n        ethoToken = IEthoToken(_ethoToken);\n        pobNFT = IProofOfBurn(_pobNFT);\n        treasury = IDAOTreasury(_treasury);\n    }\n    \n    // ============ External Functions ============\n    \n    /**\n     * @notice Make a ceremonial offering by burning ETHO tokens\n     * @param amount Amount of ETHO to burn (in wei)\n     * @param intention Encrypted intention/prayer (32 bytes)\n     */\n    function makeOffering(\n        uint256 amount,\n        bytes32 intention\n    ) external payable nonReentrant whenNotPaused {\n        require(amount > 0, "Amount must be > 0");\n        require(msg.value > 0, "Must send ETH donation");\n        \n        // Burn ETHO tokens from user\n        ethoToken.burnFrom(msg.sender, amount);\n        \n        // Mint POB NFT as receipt\n        uint256 pobTokenId = pobNFT.mint(msg.sender, amount, intention);\n        \n        // Update statistics\n        totalBurned += amount;\n        totalOfferings++;\n        userTotalBurned[msg.sender] += amount;\n        userOfferingCount[msg.sender]++;\n        \n        // Route ETH to treasury\n        treasury.deposit{value: msg.value}();\n        \n        emit OfferingMade(\n            msg.sender,\n            amount,\n            pobTokenId,\n            intention,\n            block.timestamp\n        );\n        \n        emit TreasuryDeposit(msg.value);\n    }\n    \n    /**\n     * @notice Get user\'s offering statistics\n     * @param user Address to query\n     * @return totalBurned Total ETHO burned by user\n     * @return offeringCount Number of offerings made\n     */\n    function getUserStats(address user) external view returns (\n        uint256 totalBurned_,\n        uint256 offeringCount\n    ) {\n        return (\n            userTotalBurned[user],\n            userOfferingCount[user]\n        );\n    }\n    \n    // ============ Admin Functions ============\n    \n    /**\n     * @notice Pause the contract in case of emergency\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n    \n    /**\n     * @notice Unpause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"key-features-explained",children:"Key Features Explained"}),"\n",(0,s.jsx)(n.h4,{id:"1-reentrancyguard",children:"1. ReentrancyGuard"}),"\n",(0,s.jsxs)(n.p,{children:["Prevents ",(0,s.jsx)(n.strong,{children:"reentrancy attacks"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// Without ReentrancyGuard\nfunction makeOffering() external {\n    // 1. User calls makeOffering\n    // 2. Contract sends ETH to treasury\n    // 3. Treasury's receive() calls makeOffering again\n    // 4. Infinite loop drains contract\n}\n\n// With ReentrancyGuard\nfunction makeOffering() external nonReentrant {\n    // \u2705 Second call reverts - attack prevented\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"2-pausable",children:"2. Pausable"}),"\n",(0,s.jsxs)(n.p,{children:["Allows ",(0,s.jsx)(n.strong,{children:"emergency stops"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// If a bug is discovered, owner can pause\nfunction pause() external onlyOwner {\n    _pause();\n}\n\n// All functions with whenNotPaused modifier will revert\nfunction makeOffering() external whenNotPaused {\n    // This won't execute when paused\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"3-immutable-references",children:"3. Immutable References"}),"\n",(0,s.jsxs)(n.p,{children:["Token addresses ",(0,s.jsx)(n.strong,{children:"can't be changed"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// \u2705 Set once in constructor, never changes\nIEthoToken public immutable ethoToken;\n\n// \u274c Could be changed by malicious owner\n// IEthoToken public ethoToken;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"4-event-logging",children:"4. Event Logging"}),"\n",(0,s.jsxs)(n.p,{children:["All offerings are ",(0,s.jsx)(n.strong,{children:"permanently recorded"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'event OfferingMade(\n    address indexed user,      // Indexed for filtering\n    uint256 amount,\n    uint256 pobTokenId,\n    bytes32 intention,         // Private prayer/intention\n    uint256 timestamp\n);\n\n// Frontend can listen for events\ncontract.on("OfferingMade", (user, amount, tokenId, intention, timestamp) => {\n    console.log(`${user} burned ${amount} ETHO`);\n});\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-security-patterns",children:"\ud83d\udd12 Security Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"1-checks-effects-interactions",children:"1. Checks-Effects-Interactions"}),"\n",(0,s.jsx)(n.p,{children:"Always follow this order:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'function makeOffering(uint256 amount) external {\n    // \u2705 CHECKS: Validate inputs\n    require(amount > 0, "Amount must be > 0");\n    require(msg.value > 0, "Must send ETH");\n    \n    // \u2705 EFFECTS: Update state\n    totalBurned += amount;\n    userTotalBurned[msg.sender] += amount;\n    \n    // \u2705 INTERACTIONS: External calls last\n    ethoToken.burnFrom(msg.sender, amount);\n    treasury.deposit{value: msg.value}();\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Why?"})," Prevents reentrancy and ensures state is consistent."]}),"\n",(0,s.jsx)(n.h3,{id:"2-pull-over-push",children:"2. Pull Over Push"}),"\n",(0,s.jsxs)(n.p,{children:["Let users ",(0,s.jsx)(n.strong,{children:"withdraw"})," rather than ",(0,s.jsx)(n.strong,{children:"sending"})," to them:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// \u274c PUSH: Dangerous\nfunction distributeRewards(address[] memory users) external {\n    for (uint i = 0; i < users.length; i++) {\n        // If one user's receive() reverts, entire tx fails\n        payable(users[i]).transfer(rewards[users[i]]);\n    }\n}\n\n// \u2705 PULL: Safe\nmapping(address => uint256) public rewards;\n\nfunction claimReward() external {\n    uint256 amount = rewards[msg.sender];\n    rewards[msg.sender] = 0;  // Clear before sending\n    payable(msg.sender).transfer(amount);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-integer-overflow-protection",children:"3. Integer Overflow Protection"}),"\n",(0,s.jsxs)(n.p,{children:["Solidity 0.8+ has ",(0,s.jsx)(n.strong,{children:"built-in overflow checks"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'// Solidity 0.7 and below\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, "Overflow");  // Manual check\n    return c;\n}\n\n// Solidity 0.8+\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a + b;  // \u2705 Automatic overflow check\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"4-access-control",children:"4. Access Control"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.strong,{children:"OpenZeppelin's AccessControl"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'import "@openzeppelin/contracts/access/AccessControl.sol";\n\ncontract DAOTreasury is AccessControl {\n    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");\n    bytes32 public constant EXECUTOR_ROLE = keccak256("EXECUTOR_ROLE");\n    \n    constructor() {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, msg.sender);\n    }\n    \n    function executeProposal(uint256 proposalId) external onlyRole(EXECUTOR_ROLE) {\n        // Only executors can call this\n    }\n    \n    function grantExecutor(address account) external onlyRole(ADMIN_ROLE) {\n        _grantRole(EXECUTOR_ROLE, account);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-testing-strategy",children:"\ud83e\uddea Testing Strategy"}),"\n",(0,s.jsx)(n.h3,{id:"unit-tests",children:"Unit Tests"}),"\n",(0,s.jsx)(n.p,{children:"Test each function in isolation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'describe("SacredAltar", function () {\n    it("Should burn ETHO and mint POB NFT", async function () {\n        const amount = ethers.utils.parseEther("100");\n        const intention = ethers.utils.formatBytes32String("Peace");\n        \n        // Approve ETHO spending\n        await ethoToken.approve(altar.address, amount);\n        \n        // Make offering\n        await expect(\n            altar.makeOffering(amount, intention, { value: ethers.utils.parseEther("0.1") })\n        )\n            .to.emit(altar, "OfferingMade")\n            .withArgs(user.address, amount, 1, intention, anyValue);\n        \n        // Verify ETHO was burned\n        expect(await ethoToken.balanceOf(user.address)).to.equal(0);\n        \n        // Verify POB NFT was minted\n        expect(await pobNFT.ownerOf(1)).to.equal(user.address);\n    });\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"integration-tests",children:"Integration Tests"}),"\n",(0,s.jsx)(n.p,{children:"Test contracts working together:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'describe("Full Offering Flow", function () {\n    it("Should complete end-to-end offering", async function () {\n        // 1. Buy PSILO in crowdsale\n        await crowdsale.buyTokens({ value: ethers.utils.parseEther("1") });\n        \n        // 2. Stake PSILO for MDAO\n        await staking.stake(psiloAmount);\n        \n        // 3. Swap MDAO for ETHO\n        await amm.swap(mdaoToken.address, ethoToken.address, mdaoAmount);\n        \n        // 4. Burn ETHO at altar\n        await altar.makeOffering(ethoAmount, intention, { value: ethers.utils.parseEther("0.1") });\n        \n        // 5. Verify POB NFT received\n        expect(await pobNFT.balanceOf(user.address)).to.equal(1);\n    });\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"fuzzing",children:"Fuzzing"}),"\n",(0,s.jsx)(n.p,{children:"Test with random inputs:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const { FuzzedTest } = require("@openzeppelin/test-helpers");\n\ndescribe("Fuzz Testing", function () {\n    it("Should handle random inputs safely", async function () {\n        for (let i = 0; i < 1000; i++) {\n            const randomAmount = Math.floor(Math.random() * 1000000);\n            const randomIntention = ethers.utils.randomBytes(32);\n            \n            try {\n                await altar.makeOffering(randomAmount, randomIntention);\n            } catch (error) {\n                // Should revert gracefully, not crash\n                expect(error.message).to.include("revert");\n            }\n        }\n    });\n});\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-gas-optimization",children:"\ud83d\udcca Gas Optimization"}),"\n",(0,s.jsxs)(n.h3,{id:"1-use-immutable-and-constant",children:["1. Use ",(0,s.jsx)(n.code,{children:"immutable"})," and ",(0,s.jsx)(n.code,{children:"constant"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// \u274c Costs ~2100 gas per read\nuint256 public totalSupply = 10_000_000;\n\n// \u2705 Costs ~100 gas per read\nuint256 public constant TOTAL_SUPPLY = 10_000_000;\n\n// \u2705 Costs ~100 gas per read (set in constructor)\naddress public immutable TREASURY;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-pack-storage-variables",children:"2. Pack Storage Variables"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// \u274c Uses 3 storage slots (expensive)\nuint256 public a;  // Slot 0\nuint128 public b;  // Slot 1\nuint128 public c;  // Slot 2\n\n// \u2705 Uses 2 storage slots (cheaper)\nuint256 public a;  // Slot 0\nuint128 public b;  // Slot 1 (first half)\nuint128 public c;  // Slot 1 (second half)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-use-events-instead-of-storage",children:"3. Use Events Instead of Storage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// \u274c Expensive: Store all offerings on-chain\nstruct Offering {\n    address user;\n    uint256 amount;\n    uint256 timestamp;\n}\nOffering[] public offerings;  // Very expensive to iterate\n\n// \u2705 Cheap: Emit events, query off-chain\nevent OfferingMade(address user, uint256 amount, uint256 timestamp);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-deployment-strategy",children:"\ud83d\ude80 Deployment Strategy"}),"\n",(0,s.jsx)(n.h3,{id:"1-deploy-in-correct-order",children:"1. Deploy in Correct Order"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// 1. Deploy tokens\nconst PsiloToken = await ethers.getContractFactory("PsiloToken");\nconst psiloToken = await PsiloToken.deploy();\n\n// 2. Deploy NFTs\nconst ProofOfBurn = await ethers.getContractFactory("ProofOfBurn");\nconst pobNFT = await ProofOfBurn.deploy();\n\n// 3. Deploy core contracts (need token addresses)\nconst SacredAltar = await ethers.getContractFactory("SacredAltar");\nconst altar = await SacredAltar.deploy(\n    psiloToken.address,\n    pobNFT.address,\n    treasury.address\n);\n\n// 4. Grant permissions\nawait pobNFT.grantRole(MINTER_ROLE, altar.address);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-verify-on-etherscan",children:"2. Verify on Etherscan"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'npx hardhat verify --network mainnet \\\n    0x123... \\  # Contract address\n    "0x456..." "0x789..." "0xabc..."  # Constructor args\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-renounce-ownership-if-appropriate",children:"3. Renounce Ownership (if appropriate)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// After deployment and setup\naltar.renounceOwnership();  // No one can pause/unpause anymore\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-resources",children:"\ud83d\udcda Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.openzeppelin.com/contracts/",children:"OpenZeppelin Contracts"})})," - Secure contract libraries"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.soliditylang.org/",children:"Solidity Docs"})})," - Official language documentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://hardhat.org/",children:"Hardhat"})})," - Development environment"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://etherscan.io/",children:"Etherscan"})})," - Blockchain explorer"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://github.com/drasticstatic/gratitude-token-project",children:"GitHub Repo"})})," - Full source code"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:'"Every line of code is a prayer. Every test is an act of faith. Every deployment is an offering."'})," \ud83c\udf44\u2728"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},6771:e=>{e.exports=JSON.parse('{"permalink":"/gratitude-token-project_docs/learn/smart-contract-architecture-deep-dive","source":"@site/learn/2025-10-13-smart-contract-architecture-deep-dive.md","title":"Smart Contract Architecture Deep Dive","description":"Welcome to a comprehensive exploration of the Ethereal Offering smart contract architecture. In this post, we\'ll dive deep into how our contracts are structured, the design patterns we use, and the security considerations that guide our development.","date":"2025-10-13T00:00:00.000Z","tags":[{"inline":false,"label":"Solidity","permalink":"/gratitude-token-project_docs/learn/tags/solidity","description":"Solidity smart contract development"},{"inline":false,"label":"Smart Contracts","permalink":"/gratitude-token-project_docs/learn/tags/smart-contracts","description":"Smart contract architecture and patterns"},{"inline":false,"label":"Ethereum","permalink":"/gratitude-token-project_docs/learn/tags/ethereum","description":"Ethereum blockchain development"},{"inline":false,"label":"Architecture","permalink":"/gratitude-token-project_docs/learn/tags/architecture","description":"System architecture and design patterns"},{"inline":false,"label":"Technical","permalink":"/gratitude-token-project_docs/learn/tags/technical","description":"Technical development updates and insights"}],"readingTime":8.18,"hasTruncateMarker":true,"authors":[{"name":"TranscendentVioletVoyager","title":"Custodian | Founder | Steward & Lead Developer","url":"https://github.com/drasticstatic","page":{"permalink":"/gratitude-token-project_docs/learn/authors/christopher"},"socials":{"github":"https://github.com/drasticstatic"},"imageURL":"/gratitude-token-project_docs/img/violet-voyager.webp","key":"christopher"}],"frontMatter":{"slug":"smart-contract-architecture-deep-dive","title":"Smart Contract Architecture Deep Dive","authors":["christopher"],"tags":["solidity","smart-contracts","ethereum","architecture","technical"]},"unlisted":false,"nextItem":{"title":"Understanding React Components in Web3 dApps","permalink":"/gratitude-token-project_docs/learn/understanding-react-components-web3"}}')},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(6540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);